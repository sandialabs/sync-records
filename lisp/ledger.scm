(define-class (ledger)
  (define* (~field self name value)
    (let ((address (case name
                     ((standard) '(1 0 0 0))
                     ((config) '(1 0 0 1))
                     ((stage) '(1 0 1 0))
                     ((temp) '(1 0 1 1))
                     ((perm) '(1 1 1))
                     (else 'case-error "Field not found"))))
      (if value (set! (self address) (value))
          (let ((node (self address)))
            ((eval (byte-vector->expression (sync-car node))) node)))))

  (define* (~path-check self path peer-okay?)
    (cond ((not (list? (car path)))
           (error 'path-error "Expected a list in the next path element"))
          ((and (not peer-okay?) (eq? (caar path) '*peer*))
           (error 'path-error "Expected the first element in the next path element to be '*state*"))
          ((not (or (eq? (caar path) '*state*) (eq? (caar path) '*peer*)))
           (error 'path-error "Expected the first element in the next path element to be '*state* or '*peer*"))
          (else #t)))

  (define (~signature-sign! self chain)
    (let* ((config ((self '~field) 'config))
           (standard ((self '~field) 'standard))
           (public-key ((config 'get) '(public public-key)))
           (secret-key ((config 'get) '(private secret-key))))
      ((standard 'deep-set!) chain '(-1 (*crypto* public-key)) #u())
      ((standard 'deep-set!) chain '(-1 (*crypto* signature)) #u())
      ((standard 'deep-call!) chain '(-1)
       (lambda (tree)
         ((tree 'set!) '(*crypto* public-key) public-key)
         ((tree 'set!) '(*crypto* signature) (crypto-sign secret-key (sync-digest (chain))))))))

  (define (~signature-verify self chain public-key)
    (let* ((config ((self '~field) 'config))
           (standard ((self '~field) 'standard))
           (chain-copy ((standard 'load) (chain))))
      ((standard 'deep-set!) chain-copy '(-1 (*crypto* public-key)) #u())
      ((standard 'deep-set!) chain-copy '(-1 (*crypto* signature)) #u())
      ((standard 'deep-call!) chain '(-1)
       (lambda (tree)
         (let ((included-key ((tree 'get) '(*crypto* public-key)))
               (signature ((tree 'get) '(*crypto* signature))))
           (cond ((or (null? signature) (null? included-key))
                  (error 'signature-error "Chain doesn not include necessary public key and signature"))
                 ((and public-key (not (equal? public-key included-key)))
                  (error 'signature-error "Included key does not match expected public key"))
                 ((not (crypto-verify public-key signature (sync-digest (chain-copy))))
                  (error 'signature-error "Included signature does not verify"))
                 (else #t)))))))

  (define (*init* self standard config)
    (let ((tree-class ((config 'get) '(private tree-class)))
          (chain-class ((config 'get) '(private chain-class))))
      ((self '~field) 'standard standard)
      ((self '~field) 'config config)
      ((self '~field) 'stage ((standard 'make) tree-class))
      ((self '~field) 'temp ((standard 'make) chain-class))
      ((self '~field) 'perm ((standard 'make) chain-class))))

  (define (configuration self)
    (((self '~field) 'config) 'get) '())

  (define (information self)
    ((((self '~field) 'config) 'get) '(public)))

  (define* (size self)
    (let ((perm ((self '~field) 'perm)))
      ((perm 'size))))

  (define (peer! self name info)
    (let ((config ((self '~field) 'config)))
      ((config 'set!) `(private peer ,name) info)
      ((self '~field) 'config config)))

  (define (peers self)
    (let ((config ((self '~field) 'config)))
      (map car ((config 'get) '(private peer)))))

  (define (set! self path value)
    ((self '~path-check) path)
    (let ((standard ((self '~field) 'standard))
          (stage ((self '~field) 'stage)))
      ((standard 'deep-set!) stage path value)
      ((self '~field) 'stage stage)))

  (define* (get self path)
    (let ((standard ((self '~field) 'standard)))
      (if (not (integer? (car path)))
          (let ((stage ((self '~field) 'stage)))
            ((self '~path-check) path)
            ((standard 'deep-get) stage path))
          (let ((obj ((self '~fetch) path)))
            ((standard 'deep-get) obj path)))))

  (define (pin! self path)
    ((self '~path-check) (cdr path) #t)
    (let* ((standard ((self '~field) 'standard))
           (perm ((self '~field) 'perm))
           (obj ((self '~fetch) path #t)))
      ((standard 'deep-merge!) obj perm)
      ((self '~field) 'perm perm)))

  (define (unpin! self path)
    ((self '~path-check) (cdr path) #t)
    (let* ((standard ((self '~field) 'standard))
           (perm ((self '~field) 'perm)))
      ((standard 'deep-prune!) perm path)
      ((self '~field) 'perm perm)))

  (define* (synchronize self index)
    (let ((standard ((self '~field) 'standard))
          (perm ((self '~field) 'perm)))
      ((standard 'serialize) (perm)
       `(lambda (node)
          (let ((chain ((eval (byte-vector->expression (sync-car node))) node)))
            (if (> ((chain 'size)) 0)
                (let* ((node ((chain 'get) -1))
                       (tree ((eval (byte-vector->expression (sync-car node))) node)))
                  ((tree 'get) '(*crypto* public-key))
                  ((tree 'get) '(*crypto* signature))
                  ((chain 'digest) ,index))))))))

  (define (resolve self index path)
    ((self '~path-check) (cdr path) #t)
    (let ((standard ((self '~field) 'standard))
          (obj ((self '~fetch) path #t index)))
      ((standard 'serialize) (obj)
       `(lambda (node)
          (letrec ((chain ((eval (byte-vector->expression (sync-car node))) node))
                   (deep-get (lambda (object path)
                               (if (null? path) object
                                   (let ((node ((object 'get) (car path))))
                                     (if (not (sync-node? node)) (deep-get node (cdr path))
                                         (let ((object ((eval (byte-vector->expression (sync-car node))) node)))
                                           (deep-get object (cdr path)))))))))
            (deep-get chain ',path))))))
  
  (define (step-peer! self name)
    (let* ((config ((self '~field) 'config))
           (standard ((self '~field) 'standard))
           (perm ((self '~field) 'perm))
           (stage ((self '~field) 'stage)))
      (if (eq? ((config 'get) `(private peer ,name)) '()) #f
          (let* ((value ((standard 'deep-get) perm `(-1 (*peer* ,name chain))))
                 (last (if (procedure? value) value #f))
                 (index (if last (- ((last 'size)) 1) -1))
                 (synchronize (eval ((config 'get) `(private peer ,name synchronize))))
                 (serialized (synchronize index))
                 (deserialized ((standard 'deserialize) serialized))
                 (latest ((standard 'load) deserialized)))
            (if (= ((latest 'size)) 0)
                ((stage 'set!) `(*peer* ,name valid?) #t)
                (begin ((self '~signature-verify) latest ((config 'get) `(private peer ,name public-key)))
                       ((stage 'set!) `(*peer* ,name valid?)
                        (if (and last (> ((last 'size)) 0))
                            (equal? ((last 'digest)) ((latest 'digest) index)) #t))))
            ((stage 'set!) `(*peer* ,name chain) (latest))
            ((self '~field) 'stage stage)))))

  (define (step-chain! self)
    (let* ((config ((self '~field) 'config))
           (window ((config 'get) '(public window)))
           (standard ((self '~field) 'standard))
           (stage ((self '~field) 'stage))
           (perm ((self '~field) 'perm))
           (temp ((self '~field) 'temp)))
      ((perm 'push!) (stage))
      ((self '~signature-sign!) perm)
      ((temp 'push!) ((perm 'get) -1))
      (if (and window (>= ((temp 'size)) window)) ((temp 'prune!) (- window)))
      ((standard 'deep-prune!) perm '(-1 (*state*)))
      ((self '~field) 'perm perm)
      ((self '~field) 'temp temp)
      ((perm 'size))))

  (define (step-generate self)
    (let ((config ((self '~field) 'config)))
      (let loop ((peers ((config 'get) '(private peer))) (steps '((step-chain!))))
        (if (null? peers) (reverse steps)
            (loop (cdr peers) (cons `(step-peer! ,(caar peers)) steps))))))

  (define* (~fetch self path slice? (index -1))
    (let* ((config ((self '~field) 'config))
           (standard ((self '~field) 'standard))
           (perm ((self '~field) 'perm))
           (window ((config 'get) '(public window)))
           (target ((perm 'index) (if (>= (car path) 0) (car path) (+ index 1 (car path)))))
           (current (- ((perm 'size)) 1)))
      (let* ((chain (if (< target (- current window)) perm ((self '~field) 'temp)))
             (chain ((chain 'previous) index)))
        (if (and (eq? (caadr path) '*peer*) (> (length path) 2))
            (let* ((pref (reverse (list-tail (reverse path) (- (length path) 2))))
                   (name (cadadr pref))
                   (head ((standard 'deep-get) chain pref)))
              (if (= ((head 'size)) 0)
                  (error 'fetch-error "Cannot fetch from remote chain of size 0")
                  (let* ((remote-index ((head 'index) -1))
                         (remote-path (cons ((head 'index) (path 2)) (list-tail path 3)))
                         (serialized ((eval ((config 'get) `(private peer ,name resolve))) remote-index remote-path))
                         (deserialized ((standard 'deserialize) serialized))
                         (body ((standard 'load) deserialized)))
                    (if (not (equal? (sync-digest (body)) (sync-digest (head))))
                        (error 'digest-error "Remote chain does not match local chain head")
                        ((standard 'deep-call!) chain pref
                         (lambda (head)
                           ((standard 'deep-merge!) body head))))
                    (if slice? ((standard 'deep-slice!) chain path)) chain)))
            (begin
              (if slice? ((standard 'deep-slice!) chain path)) chain))))))
